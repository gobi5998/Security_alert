import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:hive/hive.dart';
import 'package:path_provider/path_provider.dart';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/customButton.dart';
import 'package:security_alert/custom/customTextfield.dart';
import '../../utils/responsive_helper.dart';
import '../../widgets/responsive_widget.dart';

import '../../models/malware_report_model.dart';
import 'report_malware_2.dart';
import 'view_pending_reports.dart';
import 'malware_report_service.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../services/api_service.dart';
import 'package:geolocator/geolocator.dart';
import '../../custom/location_picker_screen.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Operating system input formatter
class OperatingSystemInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common OS characters
    final validOSRegex = RegExp(r'^[a-zA-Z0-9\s\-\.]+$');
    if (!validOSRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Location input formatter
class LocationInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common location characters
    final validLocationRegex = RegExp(r'^[a-zA-Z0-9\s\-\.\,]+$');
    if (!validLocationRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Validation functions
String? validateLocation(String? value) {
  if (value == null || value.trim().isEmpty) {
    return 'Location is required';
  }

  if (value.trim().length < 2) {
    return 'Location should be at least 2 characters';
  }

  return null;
}

class ReportMalware1 extends StatefulWidget {
  final String categoryId;
  const ReportMalware1({required this.categoryId});

  @override
  State<ReportMalware1> createState() => _ReportMalware1State();
}

class _ReportMalware1State extends State<ReportMalware1> {
  final _formKey = GlobalKey<FormState>();
  String? _Malwaretype, _infectedSystem, _DetectedSeverity;
  String? malwareTypeId;
  String? operatingSystemId;
  String? selectedLocation;
  String? selectedAddress;
  List<Map<String, dynamic>> malwareTypes = [];
  List<Map<String, dynamic>> deviceTypes = [];
  List<Map<String, dynamic>> operatingSystems = [];
  List<Map<String, dynamic>> detectionMethods = [];
  bool isOnline = true;
  bool isLoadingMalwareTypes = false;
  bool isLoadingDeviceTypes = false;
  bool isLoadingOperatingSystems = false;
  bool isLoadingDetectionMethods = false;
  String? malwareTypesError;
  String? deviceTypesError;
  String? operatingSystemsError;
  String? detectionMethodsError;
  bool isFormValid = false;

  // Controllers for real-time validation
  final TextEditingController _operatingSystemController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadMalwareTypes();
    _loadDeviceTypes();
    _loadOperatingSystems();
    _loadDetectionMethods();
    _setupNetworkListener();
    _setupValidationListeners();
  }

  void _setupValidationListeners() {
    // Location validation handled by location picker
  }

  @override
  void dispose() {
    _operatingSystemController.dispose();
    super.dispose();
  }

  bool _isFormValid() {
    return selectedLocation != null &&
        _Malwaretype != null &&
        _infectedSystem != null &&
        _DetectedSeverity != null &&
        operatingSystemId != null;
    // Alert level validation moved to Step 2
  }

  void _setupNetworkListener() {
    Connectivity().onConnectivityChanged.listen((result) {
      setState(() => isOnline = result != ConnectivityResult.none);
      if (isOnline) MalwareReportService.syncReports();
    });
  }

  Future<void> _loadMalwareTypes() async {
    setState(() {
      isLoadingMalwareTypes = true;
    });

    try {
      // Check connectivity first
      final connectivityResult = await Connectivity().checkConnectivity();
      final isOffline = connectivityResult == ConnectivityResult.none;

      if (isOffline) {
        print('üì± Offline mode - loading malware types from local storage');
        await _loadMalwareTypesFromLocal();
        return;
      }

      print('üîç UI: Starting to load malware types from backend...');
      print('üîç UI: Using category ID: ${widget.categoryId}');

      final apiService = ApiService();
      final malwareTypesData = await apiService.fetchReportTypesByCategory(
        widget.categoryId,
      );

      if (malwareTypesData.isNotEmpty) {
        setState(() {
          malwareTypes = malwareTypesData;
          isLoadingMalwareTypes = false;
        });
        print('‚úÖ UI: Malware types loaded: ${malwareTypes.length} items');

        // Save to local storage for offline use
        await _saveMalwareTypesToLocal(malwareTypesData);

        // Print the options for debugging
        for (int i = 0; i < malwareTypes.length; i++) {
          final type = malwareTypes[i];
          print('üîç UI: Type $i: ${type['name']} (ID: ${type['_id']})');
        }
      } else {
        print(
          '‚ùå UI: No malware types available from API, trying local storage',
        );
        await _loadMalwareTypesFromLocal();
      }
    } catch (e) {
      print('‚ùå UI: Error loading malware types from API: $e');
      print('üì± Falling back to local storage');
      await _loadMalwareTypesFromLocal();
    }
  }

  Future<void> _loadMalwareTypesFromLocal() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final malwareTypesJson = prefs.getString(
        'local_malware_types_${widget.categoryId}',
      );

      if (malwareTypesJson != null) {
        final localMalwareTypes = List<Map<String, dynamic>>.from(
          jsonDecode(malwareTypesJson).map((x) => Map<String, dynamic>.from(x)),
        );

        setState(() {
          malwareTypes = localMalwareTypes;
          isLoadingMalwareTypes = false;
        });
        print(
          '‚úÖ UI: Malware types loaded from local storage: ${malwareTypes.length} items',
        );
      } else {
        // Use fallback data
        setState(() {
          malwareTypes = _getFallbackMalwareTypes();
          isLoadingMalwareTypes = false;
        });
        print(
          '‚úÖ UI: Using fallback malware types: ${malwareTypes.length} items',
        );
      }
    } catch (e) {
      print('‚ùå UI: Error loading malware types from local storage: $e');
      setState(() {
        malwareTypes = _getFallbackMalwareTypes();
        isLoadingMalwareTypes = false;
      });
    }
  }

  Future<void> _saveMalwareTypesToLocal(
    List<Map<String, dynamic>> types,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(
        'local_malware_types_${widget.categoryId}',
        jsonEncode(types),
      );
      print('‚úÖ UI: Malware types saved to local storage');
    } catch (e) {
      print('‚ùå UI: Error saving malware types to local storage: $e');
    }
  }

  List<Map<String, dynamic>> _getFallbackMalwareTypes() {
    return [
      {'_id': 'virus', 'name': 'Virus'},
      {'_id': 'trojan', 'name': 'Trojan Horse'},
      {'_id': 'ransomware', 'name': 'Ransomware'},
      {'_id': 'spyware', 'name': 'Spyware'},
      {'_id': 'adware', 'name': 'Adware'},
      {'_id': 'worm', 'name': 'Worm'},
      {'_id': 'rootkit', 'name': 'Rootkit'},
      {'_id': 'other', 'name': 'Other Malware'},
    ];
  }

  Future<void> _loadDeviceTypes() async {
    setState(() {
      isLoadingDeviceTypes = true;
    });

    try {
      // Check connectivity first
      final connectivityResult = await Connectivity().checkConnectivity();
      final isOffline = connectivityResult == ConnectivityResult.none;

      if (isOffline) {
        print('üì± Offline mode - loading device types from local storage');
        await _loadDeviceTypesFromLocal();
        return;
      }

      print('üîç UI: Starting to load device types from backend...');
      print('üîç UI: Using category ID: ${widget.categoryId}');

      final apiService = ApiService();
      final deviceTypesData = await apiService.fetchDropdownByType(
        'device',
        widget.categoryId,
      );

      if (deviceTypesData.isNotEmpty) {
        setState(() {
          deviceTypes = deviceTypesData;
          isLoadingDeviceTypes = false;
        });
        print('‚úÖ UI: Device types loaded: ${deviceTypes.length} items');

        // Save to local storage for offline use
        await _saveDeviceTypesToLocal(deviceTypesData);

        // Print the options for debugging
        for (int i = 0; i < deviceTypes.length; i++) {
          final type = deviceTypes[i];
          print('üîç UI: Device type $i: ${type['name']} (ID: ${type['_id']})');
        }
      } else {
        print('‚ùå UI: No device types available from API, trying local storage');
        await _loadDeviceTypesFromLocal();
      }
    } catch (e) {
      print('‚ùå UI: Error loading device types from API: $e');
      print('üì± Falling back to local storage');
      await _loadDeviceTypesFromLocal();
    }
  }

  Future<void> _loadDeviceTypesFromLocal() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final deviceTypesJson = prefs.getString(
        'local_device_types_${widget.categoryId}',
      );

      if (deviceTypesJson != null) {
        final localDeviceTypes = List<Map<String, dynamic>>.from(
          jsonDecode(deviceTypesJson).map((x) => Map<String, dynamic>.from(x)),
        );

        setState(() {
          deviceTypes = localDeviceTypes;
          isLoadingDeviceTypes = false;
        });
        print(
          '‚úÖ UI: Device types loaded from local storage: ${deviceTypes.length} items',
        );
      } else {
        // Use fallback data
        setState(() {
          deviceTypes = _getFallbackDeviceTypes();
          isLoadingDeviceTypes = false;
        });
        print('‚úÖ UI: Using fallback device types: ${deviceTypes.length} items');
      }
    } catch (e) {
      print('‚ùå UI: Error loading device types from local storage: $e');
      setState(() {
        deviceTypes = _getFallbackDeviceTypes();
        isLoadingDeviceTypes = false;
      });
    }
  }

  Future<void> _saveDeviceTypesToLocal(List<Map<String, dynamic>> types) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(
        'local_device_types_${widget.categoryId}',
        jsonEncode(types),
      );
      print('‚úÖ UI: Device types saved to local storage');
    } catch (e) {
      print('‚ùå UI: Error saving device types to local storage: $e');
    }
  }

  List<Map<String, dynamic>> _getFallbackDeviceTypes() {
    return [
      {'_id': 'desktop', 'name': 'Desktop Computer'},
      {'_id': 'laptop', 'name': 'Laptop'},
      {'_id': 'tablet', 'name': 'Tablet'},
      {'_id': 'smartphone', 'name': 'Smartphone'},
      {'_id': 'server', 'name': 'Server'},
      {'_id': 'other', 'name': 'Other Device'},
    ];
  }

  Future<void> _loadOperatingSystems() async {
    setState(() {
      isLoadingOperatingSystems = true;
    });

    try {
      // Check connectivity first
      final connectivityResult = await Connectivity().checkConnectivity();
      final isOffline = connectivityResult == ConnectivityResult.none;

      if (isOffline) {
        print('üì± Offline mode - loading operating systems from local storage');
        await _loadOperatingSystemsFromLocal();
        return;
      }

      print('üîç UI: Starting to load operating systems from backend...');
      print('üîç UI: Using category ID: ${widget.categoryId}');

      final apiService = ApiService();
      final operatingSystemsData = await apiService.fetchDropdownByType(
        'operating System',
        widget.categoryId,
      );

      if (operatingSystemsData.isNotEmpty) {
        setState(() {
          operatingSystems = operatingSystemsData;
          isLoadingOperatingSystems = false;
        });
        print(
          '‚úÖ UI: Operating systems loaded: ${operatingSystems.length} items',
        );

        // Save to local storage for offline use
        await _saveOperatingSystemsToLocal(operatingSystemsData);

        // Print the options for debugging
        for (int i = 0; i < operatingSystems.length; i++) {
          final os = operatingSystems[i];
          print('üîç UI: OS $i: ${os['name']} (ID: ${os['_id']})');
        }
      } else {
        print(
          '‚ùå UI: No operating systems available from API, trying local storage',
        );
        await _loadOperatingSystemsFromLocal();
      }
    } catch (e) {
      print('‚ùå UI: Error loading operating systems from API: $e');
      print('üì± Falling back to local storage');
      await _loadOperatingSystemsFromLocal();
    }
  }

  Future<void> _loadOperatingSystemsFromLocal() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final operatingSystemsJson = prefs.getString(
        'local_operating_systems_${widget.categoryId}',
      );

      if (operatingSystemsJson != null) {
        final localOperatingSystems = List<Map<String, dynamic>>.from(
          jsonDecode(
            operatingSystemsJson,
          ).map((x) => Map<String, dynamic>.from(x)),
        );

        setState(() {
          operatingSystems = localOperatingSystems;
          isLoadingOperatingSystems = false;
        });
        print(
          '‚úÖ UI: Operating systems loaded from local storage: ${operatingSystems.length} items',
        );
      } else {
        // Use fallback data
        setState(() {
          operatingSystems = _getFallbackOperatingSystems();
          isLoadingOperatingSystems = false;
        });
        print(
          '‚úÖ UI: Using fallback operating systems: ${operatingSystems.length} items',
        );
      }
    } catch (e) {
      print('‚ùå UI: Error loading operating systems from local storage: $e');
      setState(() {
        operatingSystems = _getFallbackOperatingSystems();
        isLoadingOperatingSystems = false;
      });
    }
  }

  Future<void> _saveOperatingSystemsToLocal(
    List<Map<String, dynamic>> systems,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(
        'local_operating_systems_${widget.categoryId}',
        jsonEncode(systems),
      );
      print('‚úÖ UI: Operating systems saved to local storage');
    } catch (e) {
      print('‚ùå UI: Error saving operating systems to local storage: $e');
    }
  }

  List<Map<String, dynamic>> _getFallbackOperatingSystems() {
    return [
      {'_id': 'windows', 'name': 'Windows'},
      {'_id': 'macos', 'name': 'macOS'},
      {'_id': 'linux', 'name': 'Linux'},
      {'_id': 'android', 'name': 'Android'},
      {'_id': 'ios', 'name': 'iOS'},
      {'_id': 'other', 'name': 'Other OS'},
    ];
  }

  Future<void> _loadDetectionMethods() async {
    setState(() {
      isLoadingDetectionMethods = true;
    });

    try {
      // Check connectivity first
      final connectivityResult = await Connectivity().checkConnectivity();
      final isOffline = connectivityResult == ConnectivityResult.none;

      if (isOffline) {
        print('üì± Offline mode - loading detection methods from local storage');
        await _loadDetectionMethodsFromLocal();
        return;
      }

      print('üîç UI: Starting to load detection methods from backend...');
      print('üîç UI: Using category ID: ${widget.categoryId}');

      final apiService = ApiService();
      final detectionMethodsData = await apiService.fetchDropdownByType(
        'detect',
        widget.categoryId,
      );

      if (detectionMethodsData.isNotEmpty) {
        setState(() {
          detectionMethods = detectionMethodsData;
          isLoadingDetectionMethods = false;
        });
        print(
          '‚úÖ UI: Detection methods loaded: ${detectionMethods.length} items',
        );

        // Save to local storage for offline use
        await _saveDetectionMethodsToLocal(detectionMethodsData);

        // Print the options for debugging
        for (int i = 0; i < detectionMethods.length; i++) {
          final method = detectionMethods[i];
          print(
            'üîç UI: Detection method $i: ${method['name']} (ID: ${method['_id']})',
          );
        }
      } else {
        print(
          '‚ùå UI: No detection methods available from API, trying local storage',
        );
        await _loadDetectionMethodsFromLocal();
      }
    } catch (e) {
      print('‚ùå UI: Error loading detection methods from API: $e');
      print('üì± Falling back to local storage');
      await _loadDetectionMethodsFromLocal();
    }
  }

  Future<void> _loadDetectionMethodsFromLocal() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final detectionMethodsJson = prefs.getString(
        'local_detection_methods_${widget.categoryId}',
      );

      if (detectionMethodsJson != null) {
        final localDetectionMethods = List<Map<String, dynamic>>.from(
          jsonDecode(
            detectionMethodsJson,
          ).map((x) => Map<String, dynamic>.from(x)),
        );

        setState(() {
          detectionMethods = localDetectionMethods;
          isLoadingDetectionMethods = false;
        });
        print(
          '‚úÖ UI: Detection methods loaded from local storage: ${detectionMethods.length} items',
        );
      } else {
        // Use fallback data
        setState(() {
          detectionMethods = _getFallbackDetectionMethods();
          isLoadingDetectionMethods = false;
        });
        print(
          '‚úÖ UI: Using fallback detection methods: ${detectionMethods.length} items',
        );
      }
    } catch (e) {
      print('‚ùå UI: Error loading detection methods from local storage: $e');
      setState(() {
        detectionMethods = _getFallbackDetectionMethods();
        isLoadingDetectionMethods = false;
      });
    }
  }

  Future<void> _saveDetectionMethodsToLocal(
    List<Map<String, dynamic>> methods,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(
        'local_detection_methods_${widget.categoryId}',
        jsonEncode(methods),
      );
      print('‚úÖ UI: Detection methods saved to local storage');
    } catch (e) {
      print('‚ùå UI: Error saving detection methods to local storage: $e');
    }
  }

  List<Map<String, dynamic>> _getFallbackDetectionMethods() {
    return [
      {'_id': 'antivirus', 'name': 'Antivirus Software'},
      {'_id': 'manual', 'name': 'Manual Detection'},
      {'_id': 'system_alert', 'name': 'System Alert'},
      {'_id': 'user_report', 'name': 'User Report'},
      {'_id': 'network_monitoring', 'name': 'Network Monitoring'},
      {'_id': 'other', 'name': 'Other Method'},
    ];
  }

  // Add method to get current location dynamically
  Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      print('üìç Getting current location...');

      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('‚ùå Location services are disabled');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Location permission denied');
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Location permission denied forever');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print('‚úÖ Location obtained: ${position.latitude}, ${position.longitude}');

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
      };
    } catch (e) {
      print('‚ùå Error getting location: $e');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Report Malware'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              _loadMalwareTypes();
              _loadDeviceTypes();
              _loadOperatingSystems();
              _loadDetectionMethods();
            },
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 8),
              CustomDropdown(
                hint: isLoadingMalwareTypes
                    ? "Loading malware types..."
                    : "Select a Malware Type",
                value: malwareTypes.isNotEmpty
                    ? malwareTypes.firstWhere(
                        (e) => e['_id'] == malwareTypeId,
                        orElse: () => {'name': null},
                      )['name']
                    : _Malwaretype,
                items: malwareTypes.isNotEmpty
                    ? malwareTypes.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: (val) {
                  setState(() {
                    _Malwaretype = val;
                    if (malwareTypes.isNotEmpty && val != null) {
                      try {
                        final selectedType = malwareTypes.firstWhere(
                          (e) => e['name'] == val,
                          orElse: () => {'_id': null, 'name': val},
                        );
                        malwareTypeId = selectedType['_id'];
                        print(
                          'Selected malware type: $val with ID: $malwareTypeId',
                        );
                      } catch (e) {
                        print('Error setting malware type ID: $e');
                        malwareTypeId = null;
                      }
                    } else {
                      malwareTypeId = null;
                    }
                  });
                },
                label: "Malware Type*",
              ),
              if (malwareTypes.isEmpty && !isLoadingMalwareTypes)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    'No malware types available from backend',
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 8),
              CustomDropdown(
                hint: isLoadingDeviceTypes
                    ? "Loading device types..."
                    : deviceTypesError != null
                    ? "Error loading device types"
                    : "Select a Device Type",
                value: deviceTypes.isNotEmpty
                    ? deviceTypes.firstWhere(
                        (e) => e['name'] == _infectedSystem,
                        orElse: () => {'name': null},
                      )['name']
                    : _infectedSystem,
                items: deviceTypes.isNotEmpty
                    ? deviceTypes.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingDeviceTypes
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _infectedSystem = val;
                          if (deviceTypes.isNotEmpty && val != null) {
                            try {
                              final selectedType = deviceTypes.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              print(
                                'Selected device type: $val with ID: ${selectedType['_id']}',
                              );
                            } catch (e) {
                              print('Error setting device type ID: $e');
                            }
                          }
                        });
                      },
                label: 'Infected Device Type*',
              ),
              if (deviceTypesError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    deviceTypesError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),

              CustomDropdown(
                hint: isLoadingOperatingSystems
                    ? "Loading operating systems..."
                    : operatingSystemsError != null
                    ? "Error loading operating systems"
                    : "Select Operating System",
                value: operatingSystems.isNotEmpty
                    ? operatingSystems.firstWhere(
                        (e) => e['name'] == _operatingSystemController.text,
                        orElse: () => {'name': null},
                      )['name']
                    : _operatingSystemController.text,
                items: operatingSystems.isNotEmpty
                    ? operatingSystems.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingOperatingSystems
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _operatingSystemController.text = val!;
                          if (operatingSystems.isNotEmpty && val != null) {
                            try {
                              final selectedType = operatingSystems.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              operatingSystemId = selectedType['_id'];
                              print(
                                'Selected operating system: $val with ID: $operatingSystemId',
                              );
                            } catch (e) {
                              print('Error setting operating system ID: $e');
                              operatingSystemId = null;
                            }
                          } else {
                            operatingSystemId = null;
                          }
                        });
                      },
                label: 'Operating System*',
              ),
              if (operatingSystemsError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    operatingSystemsError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),
              CustomDropdown(
                hint: isLoadingDetectionMethods
                    ? "Loading detection methods..."
                    : detectionMethodsError != null
                    ? "Error loading detection methods"
                    : "Select Detection Method",
                value: detectionMethods.isNotEmpty
                    ? detectionMethods.firstWhere(
                        (e) => e['name'] == _DetectedSeverity,
                        orElse: () => {'name': null},
                      )['name']
                    : _DetectedSeverity,
                items: detectionMethods.isNotEmpty
                    ? detectionMethods.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingDetectionMethods
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _DetectedSeverity = val;
                          if (detectionMethods.isNotEmpty && val != null) {
                            try {
                              final selectedType = detectionMethods.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              print(
                                'Selected detection method: $val with ID: ${selectedType['_id']}',
                              );
                            } catch (e) {
                              print('Error setting detection method ID: $e');
                            }
                          }
                        });
                      },
                label: 'How was it Detected',
              ),
              const SizedBox(height: 23),

              // Location
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  // color: Colors.white,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.black),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        // Icon(Icons.location_on, color: Colors.grey[600]),
                        // const SizedBox(width: 8),
                        Text(
                          'Location*',
                          style: TextStyle(
                            fontWeight: FontWeight.w600,
                            color: Colors.black,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    InkWell(
                      onTap: () {
                        LocationPickerBottomSheet.show(
                          context,
                          onLocationSelected: (location, address) {
                            setState(() {
                              selectedLocation = location;
                              selectedAddress = address;
                            });
                          },
                        );
                      },
                      child: Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          // color: Colors.white,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.black),
                        ),
                        child: Row(
                          children: [
                            Icon(Icons.search, color: Colors.black, size: 20),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                selectedLocation != null
                                    ? selectedLocation!
                                    : 'Select location',
                                style: TextStyle(
                                  color: selectedLocation != null
                                      ? Colors.grey[600]
                                      : Colors.black,
                                  fontSize: 16,
                                ),
                              ),
                            ),
                            Icon(
                              Icons.arrow_forward_ios,
                              color: Colors.black,
                              size: 16,
                            ),
                          ],
                        ),
                      ),
                    ),
                    if (selectedAddress != null) ...[
                      const SizedBox(height: 8),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.blue[50],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.blue[200]!),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.location_on,
                              color: Colors.blue[600],
                              size: 16,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                selectedAddress!,
                                style: TextStyle(
                                  color: Colors.blue[700],
                                  fontSize: 14,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              if (detectionMethodsError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    detectionMethodsError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),

              // Alert Level field moved to Step 2 (report_malware_2.dart)
              // This will be handled dynamically in the next step
              const SizedBox(height: 20),

              // ElevatedButton(
              //   onPressed: () => Navigator.push(
              //         context,
              //         MaterialPageRoute(builder: (_) => const MalwareReportPage2()),
              //       ),
              //
              //   style: ElevatedButton.styleFrom(
              //         shape: RoundedRectangleBorder(
              //           borderRadius: BorderRadius.circular(6),
              //         ),
              //         backgroundColor: const Color(0xFF064FAD),
              //         minimumSize: const Size(double.infinity, 48),
              //       ),
              //   child: const Text("Next", style: TextStyle(color: Colors.white)),
              // ),
              CustomButton(
                text: 'Next',
                onPressed: () async {
                  // Trigger validation manually to show errors
                  if (_formKey.currentState!.validate()) {
                    // Validate required fields (alert level validation moved to Step 2)
                    if (_Malwaretype == null ||
                        _infectedSystem == null ||
                        operatingSystemId == null ||
                        _DetectedSeverity == null ||
                        selectedLocation == null) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Please fill all required fields'),
                        ),
                      );
                      return;
                    }

                    // Create malware report model
                    final malwareReport = MalwareReportModel(
                      id: DateTime.now().millisecondsSinceEpoch.toString(),
                      malwareType: _Malwaretype!,
                      infectedDeviceType: _infectedSystem!,
                      operatingSystem: _operatingSystemController.text,
                      detectionMethod: _DetectedSeverity!,
                      location: selectedLocation ?? '',
                      fileName: '',
                      name: '',
                      systemAffected: '',
                      alertSeverityLevel: 'Medium',
                      alertLevels: null, // Add the alert level ID
                      date: DateTime.now(),
                      reportTypeId:
                          malwareTypeId, // Set the selected malware type ID
                      locationCoordinates: selectedLocation != null
                          ? {
                              'type': 'Point',
                              'coordinates': [
                                0.0,
                                0.0,
                              ], // Will be updated by backend
                            }
                          : null,
                    );

                    print('Debug - Malware Report Data:');
                    print('Malware Type: ${_Malwaretype}');
                    print('Infected Device Type: ${_infectedSystem}');
                    print(
                      'Operating System: ${_operatingSystemController.text}',
                    );
                    print('Detection Method: ${_DetectedSeverity}');
                    print('Location: $selectedLocation');

                    // Don't save here - save only in Step 2 with complete data
                    print('üìù Malware report data prepared for Step 2');

                    try {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) =>
                              MalwareReportPage2(report: malwareReport),
                        ),
                      ).then((_) {
                        // Refresh the thread database list when returning
                        setState(() {});
                      });
                    } catch (e) {
                      print('Error navigating to MalwareReportPage2: $e');
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Error navigating to next page: $e'),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(
                          'Please fill all required fields correctly',
                        ),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                },
                fontSize: 20,
                borderCircular: 6,
                fontWeight: FontWeight.bold,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
