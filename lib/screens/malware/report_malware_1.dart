import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:hive/hive.dart';
import 'package:path_provider/path_provider.dart';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/customButton.dart';
import 'package:security_alert/custom/customTextfield.dart';
import '../../utils/responsive_helper.dart';
import '../../widgets/responsive_widget.dart';

import '../../models/malware_report_model.dart';
import 'report_malware_2.dart';
import 'view_pending_reports.dart';
import 'malware_report_service.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;

// Operating system input formatter
class OperatingSystemInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common OS characters
    final validOSRegex = RegExp(r'^[a-zA-Z0-9\s\-\.]+$');
    if (!validOSRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Location input formatter
class LocationInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common location characters
    final validLocationRegex = RegExp(r'^[a-zA-Z0-9\s\-\.\,]+$');
    if (!validLocationRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Validation functions
String? validateOperatingSystem(String? value) {
  if (value == null || value.trim().isEmpty) {
    return 'Operating system is required';
  }

  if (value.trim().length < 2) {
    return 'Operating system should be at least 2 characters';
  }

  return null;
}

String? validateLocation(String? value) {
  if (value == null || value.trim().isEmpty) {
    return 'Location is required';
  }

  if (value.trim().length < 2) {
    return 'Location should be at least 2 characters';
  }

  return null;
}

class ReportMalware1 extends StatefulWidget {
  final String categoryId;
  const ReportMalware1({required this.categoryId});

  @override
  State<ReportMalware1> createState() => _ReportMalware1State();
}

class _ReportMalware1State extends State<ReportMalware1> {
  final _formKey = GlobalKey<FormState>();
  String? _Malwaretype, _infectedSystem, _DetectedSeverity;
  String? malwareTypeId;
  List<Map<String, dynamic>> malwareTypes = [];
  bool isOnline = true;

  // Controllers for real-time validation
  final TextEditingController _operatingSystemController =
      TextEditingController();
  final TextEditingController _locationController = TextEditingController();

  // Validation states
  bool _isOperatingSystemValid = false;
  bool _isLocationValid = false;

  String _operatingSystemError = '';
  String _locationError = '';

  @override
  void initState() {
    super.initState();
    _loadMalwareTypes();
    _setupNetworkListener();
    _setupValidationListeners();
  }

  void _setupValidationListeners() {
    _operatingSystemController.addListener(_validateOperatingSystemField);
    _locationController.addListener(_validateLocationField);
  }

  @override
  void dispose() {
    _operatingSystemController.removeListener(_validateOperatingSystemField);
    _locationController.removeListener(_validateLocationField);

    _operatingSystemController.dispose();
    _locationController.dispose();
    super.dispose();
  }

  void _validateOperatingSystemField() {
    final operatingSystem = _operatingSystemController.text.trim();
    setState(() {
      _operatingSystemError = validateOperatingSystem(operatingSystem) ?? '';
      _isOperatingSystemValid =
          _operatingSystemError.isEmpty && operatingSystem.isNotEmpty;
    });
  }

  void _validateLocationField() {
    final location = _locationController.text.trim();
    setState(() {
      _locationError = validateLocation(location) ?? '';
      _isLocationValid = _locationError.isEmpty && location.isNotEmpty;
    });
  }

  bool _isFormValid() {
    return _isOperatingSystemValid &&
        _isLocationValid &&
        _Malwaretype != null &&
        _infectedSystem != null;
  }

  void _setupNetworkListener() {
    Connectivity().onConnectivityChanged.listen((result) {
      setState(() => isOnline = result != ConnectivityResult.none);
      if (isOnline) MalwareReportService.syncReports();
    });
  }

  Future<void> _loadMalwareTypes() async {
    final box = await Hive.openBox('malware_types');
    // Try to load from Hive first
    final raw = box.get(widget.categoryId);
    List<Map<String, dynamic>>? cachedTypes;
    if (raw != null) {
      cachedTypes = (raw as List)
          .map((e) => Map<String, dynamic>.from(e as Map))
          .toList();
    }

    if (cachedTypes != null && cachedTypes.isNotEmpty) {
      malwareTypes = cachedTypes;
      setState(() {});
    }

    // Always try to fetch latest from backend in background
    try {
      final latestTypes = await MalwareReportService.fetchReportTypesByCategory(
        widget.categoryId,
      );
      if (latestTypes.isNotEmpty) {
        malwareTypes = latestTypes;
        await box.put(widget.categoryId, latestTypes);
        setState(() {});
      }
    } catch (e) {
      // If offline or error, just use cached
      print('Failed to fetch latest malware types: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Report Malware')),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 8),
              CustomDropdown(
                hint: "Select a Malware Type",
                value: malwareTypes.isNotEmpty
                    ? malwareTypes.firstWhere(
                        (e) => e['_id'] == malwareTypeId,
                        orElse: () => {'name': null},
                      )['name']
                    : _Malwaretype,
                items: malwareTypes.isNotEmpty
                    ? malwareTypes.map((e) => e['name'] as String).toList()
                    : const [
                        'Virus',
                        'Worm',
                        'Trojan',
                        'Spyware',
                        'Ransomware',
                        'Adware',
                      ],
                onChanged: (val) {
                  setState(() {
                    _Malwaretype = val;
                    if (malwareTypes.isNotEmpty && val != null) {
                      try {
                        final selectedType = malwareTypes.firstWhere(
                          (e) => e['name'] == val,
                          orElse: () => {'_id': null, 'name': val},
                        );
                        malwareTypeId = selectedType['_id'];
                        print(
                          'Selected malware type: $val with ID: $malwareTypeId',
                        );
                      } catch (e) {
                        print('Error setting malware type ID: $e');
                        malwareTypeId = null;
                      }
                    } else {
                      malwareTypeId = null;
                    }
                  });
                },
                label: "Malware Type*",
              ),
              const SizedBox(height: 8),
              CustomDropdown(
                hint: "Select a Device Type",
                value: _infectedSystem,
                items: const [
                  'Desktop',
                  'Laptop',
                  'Mobile',
                  'IOT Devices',
                  'Others',
                ],
                onChanged: (val) => setState(() => _infectedSystem = val),
                label: 'Infected Device Type*',
              ),
              const SizedBox(height: 23),

              CustomTextField(
                controller: _operatingSystemController,
                hintText: 'Windows, Mac, Android, etc',
                label: 'Operating System*',
                keyboardType: TextInputType.text,
                inputFormatters: [OperatingSystemInputFormatter()],
                validator: validateOperatingSystem,
                onChanged: (val) {
                  _validateOperatingSystemField();
                },
                errorText: _operatingSystemError.isNotEmpty
                    ? _operatingSystemError
                    : null,
                suffixIcon: _operatingSystemController.text.isNotEmpty
                    ? Icon(
                        _isOperatingSystemValid
                            ? Icons.check_circle
                            : Icons.error,
                        color: _isOperatingSystemValid
                            ? Colors.green
                            : Colors.red,
                        size: 20,
                      )
                    : null,
              ),
              const SizedBox(height: 23),
              CustomDropdown(
                hint: "Select Detection Method",
                value: _DetectedSeverity,
                items: const [
                  'Antivirus Software',
                  'Manual Detection',
                  'System Alert',
                  'Performance Issues',
                  'Pop-up Messages',
                  'File Encryption',
                  'Browser Redirects',
                  'Other',
                ],
                onChanged: (val) => setState(() => _DetectedSeverity = val),
                label: 'How was it Detected',
              ),
              const SizedBox(height: 8),

              const SizedBox(height: 8),
              CustomTextField(
                controller: _locationController,
                hintText: 'City, State',
                label: 'Location*',
                keyboardType: TextInputType.text,
                inputFormatters: [LocationInputFormatter()],
                validator: validateLocation,
                onChanged: (val) {
                  _validateLocationField();
                },
                errorText: _locationError.isNotEmpty ? _locationError : null,
                suffixIcon: _locationController.text.isNotEmpty
                    ? Icon(
                        _isLocationValid ? Icons.check_circle : Icons.error,
                        color: _isLocationValid ? Colors.green : Colors.red,
                        size: 20,
                      )
                    : null,
              ),
              const SizedBox(height: 20),

              // ElevatedButton(
              //   onPressed: () => Navigator.push(
              //         context,
              //         MaterialPageRoute(builder: (_) => const MalwareReportPage2()),
              //       ),
              //
              //   style: ElevatedButton.styleFrom(
              //         shape: RoundedRectangleBorder(
              //           borderRadius: BorderRadius.circular(6),
              //         ),
              //         backgroundColor: const Color(0xFF064FAD),
              //         minimumSize: const Size(double.infinity, 48),
              //       ),
              //   child: const Text("Next", style: TextStyle(color: Colors.white)),
              // ),
              CustomButton(
                text: 'Next',
                onPressed: () async {
                  // Trigger validation manually to show errors
                  if (_formKey.currentState!.validate()) {
                    // Validate required fields
                    if (_Malwaretype == null ||
                        _infectedSystem == null ||
                        _operatingSystemController.text.isEmpty ||
                        _locationController.text.isEmpty) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Please fill all required fields'),
                        ),
                      );
                      return;
                    }

                    // Create malware report model
                    final malwareReport = MalwareReportModel(
                      id: DateTime.now().millisecondsSinceEpoch.toString(),
                      malwareType: _Malwaretype!,
                      infectedDeviceType: _infectedSystem!,
                      operatingSystem: _operatingSystemController.text,
                      detectionMethod: _DetectedSeverity ?? 'Unknown',
                      location: _locationController.text,
                      fileName: '',
                      name: '',
                      systemAffected: '',
                      alertSeverityLevel: '',
                      date: DateTime.now(),
                      reportTypeId:
                          malwareTypeId, // Set the selected malware type ID
                    );

                    print('Debug - Malware Report Data:');
                    print('Malware Type: ${_Malwaretype}');
                    print('Infected Device Type: ${_infectedSystem}');
                    print(
                      'Operating System: ${_operatingSystemController.text}',
                    );
                    print('Detection Method: ${_DetectedSeverity}');
                    print('Location: ${_locationController.text}');

                    // Don't save here - save only in Step 2 with complete data
                    print('📝 Malware report data prepared for Step 2');

                    try {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) =>
                              MalwareReportPage2(report: malwareReport),
                        ),
                      ).then((_) {
                        // Refresh the thread database list when returning
                        setState(() {});
                      });
                    } catch (e) {
                      print('Error navigating to MalwareReportPage2: $e');
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Error navigating to next page: $e'),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(
                          'Please fill all required fields correctly',
                        ),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                },
                fontSize: 20,
                borderCircular: 6,
                fontWeight: FontWeight.bold,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
