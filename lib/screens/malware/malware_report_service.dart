import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';

import '../../models/malware_report_model.dart';
import '../../models/scam_report_model.dart';
import '../../config/api_config.dart';
import '../../services/jwt_service.dart';

class MalwareReportService {
  static final _box = Hive.box<MalwareReportModel>('malware_reports');

  static Future<void> saveReport(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    }

    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      // Try to send to backend
      bool success = await sendToBackend(report);
      if (success) {
        report.isSynced = true;
      }
    }
    // Always save to local storage
    await _box.add(report);
  }

  static Future<void> syncReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();

    for (var report in unsyncedReports) {
      try {
        // Send to backend with upsert logic
        final success = await MalwareReportService.sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = box.keyAt(box.values.toList().indexOf(report));
          final updated = report.copyWith(isSynced: true);
          await box.put(key, updated);
        }
      } catch (e) {
        print('Failed to sync report: $e');
      }
    }
  }

  static Future<bool> sendToBackend(MalwareReportModel report) async {
    try {
      final response = await http.post(
        Uri.parse('${ApiConfig.baseUrl2}/reports'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode({
          'malwareType': report.malwareType,
          'infectedDeviceType': report.infectedDeviceType,
          'operatingSystem': report.operatingSystem,
          'detectionMethod': report.detectionMethod,
          'location': report.location,
          'name': report.name,
          'systemAffected': report.systemAffected,
          'alertSeverityLevel': report.alertSeverityLevel,
          'fileName': report.fileName,
          'date': report.date.toIso8601String(),
          'id': report.id,
          'keycloackUserId': report.keycloakUserId,
        }),
      );

      print('Send to backend response status: ${response.statusCode}');
      print('Send to backend response body: ${response.body}');

      return response.statusCode == 200 || response.statusCode == 201;
    } catch (e) {
      print('Error sending to backend: $e');
      return false;
    }
  }

  static List<MalwareReportModel> getLocalReports() {
    return _box.values.toList();
  }

  static Future<void> saveReportOffline(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    }
    print('Saving malware report to local storage: ${report.toJson()}');
    await _box.add(report);
    print('Malware report saved successfully. Box length: ${_box.length}');
  }

  static Future<void> updateReport(MalwareReportModel report) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.put(report.id, report);
  }

  static Future<void> updateExistingReportsWithKeycloakUserId() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      if (report.keycloakUserId == null) {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          final updatedReport = report.copyWith(keycloakUserId: keycloakUserId);
          final key = box.keyAt(i);
          await box.put(key, updatedReport);
        }
      }
    }
  }

  static Future<void> removeDuplicateReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final seenIds = <String>{};
    final toDelete = <int>[];

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      final uniqueId = '${report.id}_${report.name}_${report.date}';

      if (seenIds.contains(uniqueId)) {
        toDelete.add(i);
      } else {
        seenIds.add(uniqueId);
      }
    }

    // Delete duplicates in reverse order to maintain indices
    for (int i = toDelete.length - 1; i >= 0; i--) {
      final key = box.keyAt(toDelete[i]);
      await box.delete(key);
    }

    print('Removed ${toDelete.length} duplicate malware reports');
  }

  static Future<List<Map<String, dynamic>>?> fetchReportTypesByCategory(
    String categoryId,
  ) async {
    try {
      final response = await http.get(
        Uri.parse('${ApiConfig.baseUrl2}/report-types?categoryId=$categoryId'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);
        return data.map((e) => Map<String, dynamic>.from(e)).toList();
      }
      return null;
    } catch (e) {
      print('Error fetching malware report types: $e');
      return null;
    }
  }
}
