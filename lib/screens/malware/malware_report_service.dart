import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';

import '../../models/malware_report_model.dart';
import '../../config/api_config.dart';
import '../../services/api_service.dart';
import '../../services/jwt_service.dart';
import '../../services/malware_reference_service.dart';

class MalwareReportService {
  static final _box = Hive.box<MalwareReportModel>('malware_reports');
  static final ApiService _apiService = ApiService();

  static Future<void> saveReport(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();

    // Run diagnostics if no user ID found (device-specific issue)
    if (keycloakUserId == null) {
      print('‚ö†Ô∏è No user ID found - running token storage diagnostics...');
      await JwtService.diagnoseTokenStorage();
    }

    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    } else {
      // Fallback for device-specific issues
      print('‚ö†Ô∏è Using fallback user ID for device compatibility');
      report = report.copyWith(
        keycloakUserId: 'device_user_${DateTime.now().millisecondsSinceEpoch}',
      );
    }

    // Ensure unique timestamp for each report
    final now = DateTime.now();
    final uniqueOffset = (report.id.hashCode) % 1000;
    final uniqueTimestamp = now.add(Duration(milliseconds: uniqueOffset));
    report = report.copyWith(date: uniqueTimestamp);

    // Always save to local storage first (offline-first approach)
    await _box.add(report);
    print(
      '‚úÖ Malware report saved locally with type ID: ${report.reportTypeId}',
    );

    // Try to sync if online
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      print('üåê Online - attempting to sync report...');
      try {
        // Initialize reference service before syncing
        await MalwareReferenceService.initialize();
        bool success = await sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = _box.keyAt(
            _box.length - 1,
          ); // Get the key of the last added item
          final updated = report.copyWith(isSynced: true);
          await _box.put(key, updated);
          print('‚úÖ Malware report synced successfully!');
        } else {
          print('‚ö†Ô∏è Failed to sync report - will retry later');
        }
      } catch (e) {
        print('‚ùå Error syncing report: $e - will retry later');
      }
    } else {
      print('üì± Offline - report saved locally for later sync');
    }

    // Remove duplicates immediately after saving
    await removeDuplicateReports();
  }

  static Future<void> saveReportOffline(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    }

    print('Saving malware report to local storage: ${report.toJson()}');
    await _box.add(report);

    // Remove duplicates immediately after saving (like scam/fraud)
    await removeDuplicateReports();

    print('Malware report saved successfully. Box length: ${_box.length}');
  }

  static Future<void> syncReports() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity == ConnectivityResult.none) {
      print('üì± No internet connection - cannot sync');
      return;
    }

    // Initialize reference service before syncing
    print('üîÑ Initializing malware reference service...');
    await MalwareReferenceService.initialize();

    // Force refresh reference data before syncing
    print('üîÑ Refreshing malware reference data before sync...');
    await MalwareReferenceService.refresh();

    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();

    print('üîÑ Syncing ${unsyncedReports.length} unsynced malware reports...');

    for (var report in unsyncedReports) {
      try {
        print('üì§ Syncing report: ${report.name}');
        final success = await MalwareReportService.sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = box.keyAt(box.values.toList().indexOf(report));
          final updated = report.copyWith(isSynced: true);
          await box.put(key, updated);
          print('‚úÖ Successfully synced: ${report.name}');
        } else {
          print('‚ùå Failed to sync: ${report.name}');
        }
      } catch (e) {
        print('‚ùå Error syncing report ${report.name}: $e');
      }
    }

    print('‚úÖ Sync completed for malware reports');
  }

  // Auto-sync when coming back online
  static Future<void> autoSyncWhenOnline() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      print('üåê Internet detected - auto-syncing malware reports...');
      await syncReports();
    }
  }

  // Test method to debug sync issues
  static Future<void> debugSync() async {
    print('üîç DEBUG: Testing malware sync process...');

    // Test all endpoints
    await MalwareReferenceService.testAllEndpoints();

    // Force refresh reference data
    await MalwareReferenceService.refresh();

    // Check if data is available
    print(
      '‚úÖ Has all required data: ${MalwareReferenceService.hasAllRequiredData}',
    );

    // Try to sync one report
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values.where((r) => !r.isSynced).toList();

    if (unsyncedReports.isNotEmpty) {
      print(
        'üì§ Testing sync with first unsynced report: ${unsyncedReports.first.name}',
      );
      final success = await sendToBackend(unsyncedReports.first);
      print('üì§ Sync test result: $success');
    } else {
      print('üì§ No unsynced reports to test');
    }
  }

  // Force sync a specific report
  static Future<bool> forceSyncReport(MalwareReportModel report) async {
    print('üîÑ Force syncing report: ${report.name}');

    // Initialize reference service before syncing
    print('üîÑ Initializing malware reference service...');
    await MalwareReferenceService.initialize();

    // Force refresh reference data
    await MalwareReferenceService.refresh();

    final success = await sendToBackend(report);
    if (success) {
      // Mark as synced
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final key = box.keyAt(box.values.toList().indexOf(report));
      final updated = report.copyWith(isSynced: true);
      await box.put(key, updated);
      print('‚úÖ Successfully force synced: ${report.name}');
    } else {
      print('‚ùå Failed to force sync: ${report.name}');
    }

    return success;
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllMalwareReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('üóëÔ∏è Cleared all malware reports');
  }

  static Future<bool> sendToBackend(MalwareReportModel report) async {
    try {
      // Use malware-drops endpoint for malware reports
      final url = '${ApiConfig.mainBaseUrl}${ApiConfig.malwareDropsEndpoint}';
      print('üîÑ Using malware-drops endpoint: $url');

      // Get actual ObjectId values from reference service
      final reportCategoryId =
          MalwareReferenceService.getMalwareReportCategoryId();
      final deviceTypeId = MalwareReferenceService.getDeviceTypeId(
        report.infectedDeviceType,
      );
      final detectTypeId = MalwareReferenceService.getDetectionTypeId(
        report.detectionMethod,
      );
      final operatingSystemId = MalwareReferenceService.getOperatingSystemId(
        report.operatingSystem,
      );

      print('üîÑ Using ObjectId values:');
      print('  - reportCategoryId: $reportCategoryId');
      print(
        '  - reportTypeId: ${report.reportTypeId} (from selected dropdown)',
      );
      print('  - deviceTypeId: $deviceTypeId');
      print('  - detectTypeId: $detectTypeId');
      print('  - operatingSystemId: $operatingSystemId');

      // Prepare data with actual ObjectId values
      final requestBody = {
        "reportCategoryId": reportCategoryId.isNotEmpty
            ? reportCategoryId
            : "687616edc688f12536d1d2d5", // Use actual ID or fallback
        "reportTypeId":
            report.reportTypeId ??
            "68761767c688f12536d1d2dd", // Use selected type ID or fallback
        "alertLevels": report.alertSeverityLevel.toLowerCase(),
        "keycloackUserId":
            report.keycloakUserId, // Fallback for no auth
        "deviceTypeId": deviceTypeId.isNotEmpty
            ? deviceTypeId
            : "687616edc688f12536d1d2d5", // Use actual ID or fallback
        "detectTypeId": detectTypeId.isNotEmpty
            ? detectTypeId
            : "68761767c688f12536d1d2dd", // Use actual ID or fallback
        "operatingSystemName": operatingSystemId.isNotEmpty
            ? operatingSystemId
            : "6875f41f652eaccf5ecbe6b2", // Use actual ID or fallback
        "location": report.location ?? "",
        "attackName": report.name ?? "Malware Report",
        "attackSystem": report.systemAffected ?? "",
        "fileName": report.fileName ?? "",
        "screenshotUrls": report.screenshotUrls ?? [],
        "voiceMessageUrls": report.voiceMessageUrls ?? [],
        "documentUrls": report.documentUrls ?? [],
        "createdBy": "user",
        "isActive": true,
      };

      print('üì§ Sending malware report to backend...');
      print('üì§ Request body: ${jsonEncode(requestBody)}');

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(requestBody),
      );

      print('üì• Response status: ${response.statusCode}');
      print('üì• Response body: ${response.body}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        print('‚úÖ Malware report synced successfully!');
        return true;
      } else {
        print('‚ùå Backend sync failed with status: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending malware report to backend: $e');
      print('üîç This might be due to:');
      print('   - Backend server is offline');
      print('   - Network connectivity issues');
      print('   - Incorrect API endpoint');
      print('   - Invalid request format');
      return false;
    }
  }

  static Future<void> updateReport(MalwareReportModel report) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.put(report.id, report);
  }

  static List<MalwareReportModel> getLocalReports() {
    print('Getting local malware reports. Box length: ${_box.length}');
    final reports = _box.values.toList();
    print('Retrieved ${reports.length} malware reports from local storage');
    return reports;
  }

  static Future<void> updateExistingReportsWithKeycloakUserId() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      if (report.keycloakUserId == null) {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          final updatedReport = report.copyWith(keycloakUserId: keycloakUserId);
          final key = box.keyAt(i);
          await box.put(key, updatedReport);
        }
      }
    }
  }

  static Future<void> removeDuplicateReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final seenContent = <String>{};
    final toDelete = <int>[];

    print('=== CLEARING MALWARE DUPLICATES ===');
    print('Before cleanup: ${reports.length} malware reports');

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      // Use content-based detection: name + type + device + location
      final contentKey =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';

      if (seenContent.contains(contentKey)) {
        toDelete.add(i);
        print(
          '‚ùå DUPLICATE FOUND: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      } else {
        seenContent.add(contentKey);
        print(
          '‚úÖ KEEPING: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      }
    }

    // Delete duplicates in reverse order to maintain indices
    for (int i = toDelete.length - 1; i >= 0; i--) {
      final key = box.keyAt(toDelete[i]);
      await box.delete(key);
      print('üóëÔ∏è DELETED: ${reports[toDelete[i]].name}');
    }

    final remainingReports = box.values.toList();
    print('After cleanup: ${remainingReports.length} malware reports');
    print('Removed ${toDelete.length} duplicate malware reports');
    print('=== END MALWARE DUPLICATE CLEANUP ===');
  }

  // STRICT duplicate check - Check for exact duplicates before saving
  static Future<bool> checkForExactDuplicate(
    MalwareReportModel newReport,
  ) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final existingReports = box.values.toList();

    print(
      'üîç STRICT DUPLICATE CHECK: ${newReport.name} (${newReport.malwareType})',
    );

    for (final existingReport in existingReports) {
      // Check for EXACT match (name + type + device + location)
      if (existingReport.name == newReport.name &&
          existingReport.malwareType == newReport.malwareType &&
          existingReport.infectedDeviceType == newReport.infectedDeviceType &&
          existingReport.location == newReport.location) {
        print(
          '‚ùå EXACT DUPLICATE FOUND: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
        );
        return true;
      }
    }
    print('‚úÖ No exact duplicate found for: ${newReport.name}');
    return false;
  }

  // Check if a report is a duplicate before saving (legacy method)
  static Future<bool> isDuplicateReport(MalwareReportModel newReport) async {
    return await checkForExactDuplicate(newReport);
  }

  // Force cleanup all duplicates immediately
  static Future<void> forceCleanupDuplicates() async {
    print('üßπ FORCE CLEANING ALL MALWARE DUPLICATES...');
    await removeDuplicateReports();
    print('‚úÖ Force cleanup completed');
  }

  // AGGRESSIVE duplicate removal - removes ALL duplicates
  static Future<void> aggressiveDuplicateRemoval() async {
    print('üî• AGGRESSIVE DUPLICATE REMOVAL...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    print('üìä Total reports before: ${reports.length}');

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING: ${report.name} (${report.malwareType})');
      }
    }

    // Clear everything and add only unique
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ AGGRESSIVE CLEANUP COMPLETED! Kept ${uniqueReports.length} unique reports',
    );
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('üóëÔ∏è All malware reports cleared');
  }

  // Clear all duplicates and keep only unique reports
  static Future<void> clearAllDuplicates() async {
    print('üßπ CLEARING ALL DUPLICATES AND KEEPING ONLY UNIQUE REPORTS...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING DUPLICATE: ${report.name} (${report.malwareType})');
      }
    }

    // Clear box and add only unique reports
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ Duplicate cleanup completed. Kept ${uniqueReports.length} unique reports',
    );
  }

  // Test method to verify auto-sync
  static Future<void> testAutoSync() async {
    print('üß™ TESTING AUTO SYNC...');

    // Check connectivity
    final connectivity = await Connectivity().checkConnectivity();
    print('üåê Connectivity: $connectivity');

    // Check unsynced reports
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();
    print('üìä Unsynced reports: ${unsyncedReports.length}');

    // Try to sync
    if (connectivity != ConnectivityResult.none) {
      await syncReports();
    } else {
      print('‚ùå No internet connection for testing');
    }
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypes() async {
    return await _apiService.fetchReportTypes();
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypesByCategory(
    String categoryId,
  ) async {
    return await _apiService.fetchReportTypesByCategory(categoryId);
  }

  static Future<List<Map<String, dynamic>>> fetchReportCategories() async {
    final categories = await _apiService.fetchReportCategories();
    print('API returned: $categories'); // Debug print
    return categories;
  }

  // Test duplicate detection
  static Future<void> testDuplicateDetection() async {
    print('üß™ TESTING DUPLICATE DETECTION...');

    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    print('üìä Total reports: ${reports.length}');

    final seenKeys = <String>{};
    final duplicates = <String>[];

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (seenKeys.contains(key)) {
        duplicates.add('${report.name} (${report.malwareType})');
        print('‚ùå DUPLICATE: ${report.name} (${report.malwareType})');
      } else {
        seenKeys.add(key);
        print('‚úÖ UNIQUE: ${report.name} (${report.malwareType})');
      }
    }

    print('üìä Found ${duplicates.length} duplicates');
    if (duplicates.isNotEmpty) {
      print('‚ùå Duplicates found: ${duplicates.join(', ')}');
    } else {
      print('‚úÖ No duplicates found!');
    }
  }

  // NUCLEAR OPTION - Clear everything and start fresh
  static Future<void> nuclearCleanup() async {
    print('‚ò¢Ô∏è NUCLEAR CLEANUP - CLEARING ALL MALWARE DATA...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('‚úÖ ALL MALWARE DATA CLEARED - FRESH START');
  }
}
